<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minesweeper 9√ó9</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --cell-size: 42px;
      --gap: 4px;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body {
      font-family: var(--font);
      display: grid;
      place-items: center;
      min-height: 100vh;
      background: #f3f4f6;
      margin: 0;
      padding: 24px;
    }
    .wrap {
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      padding: 16px 16px 20px;
      width: max-content;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 8px 0;
      text-align: center;
    }
    .toolbar {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .toolbar .stat {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 600;
    }
    .toolbar button {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      background: #fff;
      cursor: pointer;
    }
    .toolbar button:hover { background: #f0f9ff; }

    #board {
      display: grid;
      grid-template-columns: repeat(9, var(--cell-size));
      gap: var(--gap);
      user-select: none;
    }
    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 16px;
      border-radius: 6px;
      border: 1px solid #94a3b8;
      background: #e2e8f0;
      cursor: pointer;
      line-height: 1;
    }
    .cell.revealed {
      background: #ffffff;
      border-color: #cbd5e1;
      cursor: default;
    }
    .cell.mine.revealed {
      background: #fee2e2;
      border-color: #ef4444;
    }
    .cell.flagged {
      background: #fef3c7;
      border-color: #f59e0b;
    }
    .status {
      text-align: center;
      margin-top: 10px;
      min-height: 24px;
      font-weight: 600;
    }

    /* Number coloring like classic Minesweeper */
    .n1 { color: #2563eb; } .n2 { color: #16a34a; } .n3 { color: #dc2626; }
    .n4 { color: #7c3aed; } .n5 { color: #b45309; } .n6 { color: #0891b2; }
    .n7 { color: #0f766e; } .n8 { color: #111827; }

    /* Subtle shake animation when chording fails (flags mismatch) */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      50% { transform: translateX(2px); }
      75% { transform: translateX(-1px); }
    }
    .shake { animation: shake 180ms ease-in-out; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üí£ Minesweeper (9√ó9, 10 mines)</h1>
    <div class="toolbar">
      <div class="stat">‚è±Ô∏è Time: <span id="time">0</span>s</div>
      <div class="stat">üö© Flags left: <span id="flagsLeft">10</span></div>
      <button id="flagModeBtn" aria-pressed="false">üö© Flag Mode: OFF</button>
      <button id="resetBtn">üîÑ Reset</button>
    </div>
    <div id="board" role="grid" aria-label="Minesweeper board"></div>
    <div class="status" id="status"></div>
  </div>

  <script>
    // --- Config ---
    const ROWS = 9, COLS = 9, MINES = 10;

    // --- DOM ---
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const timeEl = document.getElementById('time');
    const flagsLeftEl = document.getElementById('flagsLeft');
    const resetBtn = document.getElementById('resetBtn');
    const flagModeBtn = document.getElementById('flagModeBtn');

    // --- State ---
    let board = [];                 // 2D array of cell objects
    let started = false;            // first click triggered?
    let gameOver = false;
    let flagsLeft = MINES;
    let revealedSafeCount = 0;
    let timerId = null;
    let elapsed = 0;
    let flagMode = false;           // mobile-friendly toggle for flagging

    // --- Cell factory ---
    const makeCell = (r, c) => ({
      r, c,
      mine: false,
      revealed: false,
      flagged: false,
      count: 0, // neighboring mines
      el: null
    });

    // --- Helpers ---
    const neighbors = (r, c) => {
      const res = [];
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) res.push(board[nr][nc]);
        }
      }
      return res;
    };

    const startTimer = () => {
      if (timerId) return;
      timerId = setInterval(() => {
        elapsed++;
        timeEl.textContent = String(elapsed);
      }, 1000);
    };

    const setGameOver = (msg) => {
      gameOver = true;
      clearInterval(timerId);
      statusEl.textContent = msg || '';
    };

    const updateFlagsLeft = () => {
      flagsLeftEl.textContent = String(flagsLeft);
    };

    // --- Board init & mine placement ---
    const initBoard = () => {
      // Build data model
      board = Array.from({ length: ROWS }, (_, r) =>
                Array.from({ length: COLS }, (_, c) => makeCell(r, c)));

      // Reset UI
      boardEl.innerHTML = '';
      boardEl.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;

      // Create DOM cells
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          const div = document.createElement('button');
          div.className = 'cell';
          div.setAttribute('role', 'gridcell');
          div.setAttribute('aria-label', `Cell ${r+1},${c+1}`);

          // Left click (reveal or chord if flag mode is on)
          div.addEventListener('click', () => onLeftClick(cell));

          // Right click (flag)
          div.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            onRightClick(cell);
          });

          // Long-press to flag (mobile)
          let pressTimer = null;
          div.addEventListener('pointerdown', () => {
            pressTimer = setTimeout(() => onRightClick(cell), 450);
          });
          const clearPressTimer = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } };
          div.addEventListener('pointerup', clearPressTimer);
          div.addEventListener('pointerleave', clearPressTimer);

          // Double-click chord
          div.addEventListener('dblclick', () => onChord(cell));

          // Middle-click chord (auxclick with button==1)
          div.addEventListener('auxclick', (e) => {
            if (e.button === 1) onChord(cell);
          });

          cell.el = div;
          boardEl.appendChild(div);
        }
      }

      // Reset counters
      flagsLeft = MINES;
      revealedSafeCount = 0;
      started = false;
      gameOver = false;
      elapsed = 0;
      timeEl.textContent = '0';
      updateFlagsLeft();
      statusEl.textContent = '';
      clearInterval(timerId);
      timerId = null;
    };

    const placeMines = (firstR, firstC) => {
      // Randomly place mines, excluding first clicked cell
      const indices = Array.from({ length: ROWS * COLS }, (_, i) => i);
      const excludeIndex = firstR * COLS + firstC;

      // Fisher-Yates shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      // Pick first MINES indices, skipping the exclude
      let placed = 0;
      for (let k = 0; k < indices.length && placed < MINES; k++) {
        const idx = indices[k];
        if (idx === excludeIndex) continue;
        const r = Math.floor(idx / COLS);
        const c = idx % COLS;
        board[r][c].mine = true;
        placed++;
      }

      // Compute neighbor counts
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          if (cell.mine) { cell.count = -1; continue; }
          cell.count = neighbors(r, c).filter(n => n.mine).length;
        }
      }
    };

    // --- Reveal logic (minimal patch: do NOT disable revealed cells) ---
    const reveal = (cell) => {
      if (cell.revealed) return;
      cell.revealed = true;
      cell.el.classList.add('revealed');

      // Keep element enabled to allow dblclick/middle-click for chording
      // Prevent focus styling and indicate semantic disabled
      cell.el.tabIndex = -1;
      cell.el.setAttribute('aria-disabled', 'true');

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = 'üí£';
        return;
      }

      revealedSafeCount++;
      if (cell.count > 0) {
        cell.el.textContent = String(cell.count);
        cell.el.classList.add('n' + cell.count);
      } else {
        // Flood-fill empty region (BFS)
        cell.el.textContent = '';
        const q = [cell];
        const seen = new Set([`${cell.r},${cell.c}`]);
        while (q.length) {
          const cur = q.shift();
          for (const n of neighbors(cur.r, cur.c)) {
            if (n.revealed || n.flagged || n.mine) continue;
            n.revealed = true;
            n.el.classList.add('revealed');

            // Minimal patch applied to neighbors too:
            n.el.tabIndex = -1;
            n.el.setAttribute('aria-disabled', 'true');

            revealedSafeCount++;
            if (n.count === 0) {
              n.el.textContent = '';
              const key = `${n.r},${n.c}`;
              if (!seen.has(key)) { seen.add(key); q.push(n); }
            } else {
              n.el.textContent = String(n.count);
              n.el.classList.add('n' + n.count);
            }
          }
        }
      }
    };

    const revealAllMines = () => {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          if (cell.mine) {
            cell.el.classList.add('revealed', 'mine');
            cell.el.textContent = 'üí£';
            // It's OK to leave mines enabled; gameOver prevents interaction
          }
        }
      }
    };

    const checkWin = () => {
      const totalSafe = ROWS * COLS - MINES;
      if (revealedSafeCount === totalSafe) {
        setGameOver('üéâ You win!');
        // Auto-flag remaining mines (visual only)
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const cell = board[r][c];
            if (cell.mine && !cell.flagged) {
              cell.flagged = true;
              cell.el.classList.add('flagged');
              cell.el.textContent = 'üö©';
            }
          }
        }
      }
    };

    // --- Input handlers ---
    const onLeftClick = (cell) => {
      if (gameOver) return;

      // If flag mode is ON, left-click acts as flag toggle
      if (flagMode) { onRightClick(cell); return; }

      // Prevent revealing a revealed/flagged cell via left-click
      if (cell.flagged || cell.revealed) return;

      if (!started) {
        started = true;
        startTimer();
        placeMines(cell.r, cell.c);
      }

      if (cell.mine) {
        // First click shouldn't be a mine due to deferred placement,
        // but handle gracefully anyway
        reveal(cell);
        revealAllMines();
        setGameOver('üí• Boom! Game over.');
        return;
      }

      reveal(cell);
      checkWin();
    };

    const onRightClick = (cell) => {
      if (gameOver || cell.revealed) return;
      if (!cell.flagged) {
        if (flagsLeft === 0) return;
        cell.flagged = true;
        cell.el.classList.add('flagged');
        cell.el.textContent = 'üö©';
        flagsLeft--;
      } else {
        cell.flagged = false;
        cell.el.classList.remove('flagged');
        cell.el.textContent = '';
        flagsLeft++;
      }
      updateFlagsLeft();
    };

    // --- Chord (double-click or middle-click) ---
    const onChord = (center) => {
      if (gameOver) return;
      if (!center.revealed) return;
      if (center.count <= 0) return; // only numbered cells support chording

      const ns = neighbors(center.r, center.c);
      const flagCount = ns.filter(n => n.flagged).length;

      // Flags must match the number exactly
      if (flagCount !== center.count) {
        center.el.classList.add('shake');
        setTimeout(() => center.el.classList.remove('shake'), 200);
        return;
      }

      // If any unflagged neighbor is a mine, it's a loss
      const hitMine = ns.some(n => !n.revealed && !n.flagged && n.mine);
      if (hitMine) {
        // Reveal neighbors to show what happened
        for (const n of ns) {
          if (!n.revealed && !n.flagged) reveal(n);
        }
        revealAllMines();
        setGameOver('üí• Boom! Game over.');
        return;
      }

      // Safe: reveal all unflagged, unrevealed neighbors
      for (const n of ns) {
        if (!n.revealed && !n.flagged) reveal(n);
      }
      checkWin();
    };

    // --- UI wiring ---
    resetBtn.addEventListener('click', () => initBoard());
    flagModeBtn.addEventListener('click', () => {
      flagMode = !flagMode;
      flagModeBtn.setAttribute('aria-pressed', String(flagMode));
      flagModeBtn.textContent = flagMode ? 'üö© Flag Mode: ON' : 'üö© Flag Mode: OFF';
    });

    // --- Boot ---
    initBoard();
  </script>
</body>
</html>